{"ast":null,"code":"import _toConsumableArray from \"/Users/mineshshah/minesh/drag-drop-list-framer/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/mineshshah/minesh/drag-drop-list-framer/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/mineshshah/minesh/drag-drop-list-framer/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _jsxFileName = \"/Users/mineshshah/minesh/drag-drop-list-framer/src/Example.tsx\";\nimport * as React from \"react\";\nimport { useEffect, useState, useRef } from \"react\";\nimport { motion, useMotionValue } from \"framer-motion\";\nimport { findIndex } from \"./find-index\";\nimport move from \"array-move\";\nimport Card from './Card';\nimport SubCard from \"./SubCard\";\n\nvar Item = function Item(_ref) {\n  var setPosition = _ref.setPosition,\n      moveItem = _ref.moveItem,\n      i = _ref.i,\n      rest = _objectWithoutProperties(_ref, [\"setPosition\", \"moveItem\", \"i\"]);\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isDragging = _useState2[0],\n      setDragging = _useState2[1]; // We'll use a `ref` to access the DOM element that the `motion.li` produces.\n  // This will allow us to measure its height and position, which will be useful to\n  // decide when a dragging element should switch places with its siblings.\n\n\n  var ref = useRef(null); // By manually creating a reference to `dragOriginY` we can manipulate this value\n  // if the user is dragging this DOM element while the drag gesture is active to\n  // compensate for any movement as the items are re-positioned.\n\n  var dragOriginY = useMotionValue(0); // Update the measured position of the item so we can calculate when we should rearrange.\n\n  useEffect(function () {\n    setPosition(i, {\n      height: ref.current.offsetHeight,\n      top: ref.current.offsetTop\n    });\n  });\n  return React.createElement(motion.li, Object.assign({\n    ref: ref,\n    initial: false // If we're dragging, we want to set the zIndex of that item to be on top of the other items.\n    ,\n    animate: isDragging ? onTop : flat,\n    style: {\n      height: 'auto'\n    },\n    whileHover: {\n      boxShadow: \"0px 1px 4px rgba(0, 0, 0, 0.2)\"\n    } // whileTap={{ scale: 1.12 }}\n    ,\n    drag: \"y\",\n    dragOriginY: dragOriginY,\n    dragConstraints: {\n      top: 0,\n      bottom: 0\n    },\n    dragElastic: 1,\n    onDragStart: function onDragStart(event) {\n      setDragging(true);\n    },\n    onDragEnd: function onDragEnd(event) {\n      event && event.stopImmediatePropagation();\n      setDragging(false);\n    },\n    onDrag: function onDrag(e, _ref2) {\n      var point = _ref2.point;\n      return moveItem(i, point.y);\n    } // onUpdate={({ y, top }) => {\n    //   !isDragging && dragOriginY.set((y || top) as number);\n    // }}\n    ,\n    positionTransition: function positionTransition(_ref3) {\n      var delta = _ref3.delta;\n\n      if (isDragging) {\n        // If we're dragging, we want to \"undo\" the items movement within the list\n        // by manipulating its dragOriginY. This will keep the item under the cursor,\n        // even though it's jumping around the DOM.\n        dragOriginY.set(dragOriginY.get() + delta.y);\n      } // If `positionTransition` is a function and returns `false`, it's telling\n      // Motion not to animate from its old position into its new one. If we're\n      // dragging, we don't want any animation to occur.\n\n\n      return !isDragging;\n    }\n  }, rest, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37\n    },\n    __self: this\n  }));\n};\n\nexport var ChildItem = function ChildItem(_ref4) {\n  var parentIndex = _ref4.parentIndex,\n      childIndex = _ref4.childIndex,\n      blocks = _ref4.blocks,\n      setBlocks = _ref4.setBlocks,\n      id = _ref4.id,\n      header = _ref4.header;\n  var childPositions = useRef({}).current;\n\n  var setChildPosition = function setChildPosition(childIndex, offset) {\n    return childPositions[childIndex] = offset;\n  };\n\n  var moveChildItem = function moveChildItem(childIndex, dragOffset) {\n    console.log(childPositions);\n    var targetIndex = findIndex(childIndex, dragOffset, childPositions);\n    var updatedElements = move(_toConsumableArray(blocks)[parentIndex]['elements'], childIndex, targetIndex);\n\n    var updatedBlock = _toConsumableArray(blocks);\n\n    updatedBlock[parentIndex]['elements'] = updatedElements;\n    if (targetIndex !== childIndex) setBlocks(updatedBlock);\n  };\n\n  return React.createElement(Item, {\n    key: id,\n    i: childIndex,\n    setPosition: setChildPosition,\n    moveItem: moveChildItem,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 105\n    },\n    __self: this\n  }, React.createElement(SubCard, {\n    title: header,\n    key: id,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111\n    },\n    __self: this\n  }));\n};\nexport var Example = function Example() {\n  // const [colors, setColors] = useState(initialColors);\n  var _useState3 = useState(defaultObject),\n      _useState4 = _slicedToArray(_useState3, 2),\n      blocks = _useState4[0],\n      setBlocks = _useState4[1]; // We need to collect an array of height and position data for all of this component's\n  // `Item` children, so we can later us that in calculations to decide when a dragging\n  // `Item` should swap places with its siblings.\n\n\n  var positions = useRef([]).current;\n\n  var setPosition = function setPosition(i, offset) {\n    return positions[i] = offset;\n  }; // const setChildPosition = (i: number) => ( j: number, offset: Position) => {\n  //   // console.log(positions[i])\n  //   // if (!positions[i]['elements'] ){\n  //   //   positions[i]['elements'] = []\n  //   // }\n  //   // positions[i]['elements'][j] = offset;\n  //   // childPositions[i] = childPositions[i] ?  : []\n  // };\n  // Find the ideal index for a dragging item based on its position in the array, and its\n  // current drag offset. If it's different to its current index, we swap this item with that\n  // sibling.\n\n\n  var moveItem = function moveItem(i, dragOffset) {\n    var targetIndex = findIndex(i, dragOffset, positions);\n    if (targetIndex !== i) setBlocks(move(blocks, i, targetIndex));\n  }; // const moveChildItem = (i:number) => (j: number, dragOffset: number) => {\n  //   if(positions[i]['elements']) {\n  //     // console.log(positions)\n  //     const targetIndex = findIndex(j, dragOffset, positions[i]['elements']);\n  //     const updatedElements = move([...blocks][i]['elements'], j, targetIndex);\n  //     const updatedBlock = [...blocks];\n  //     updatedBlock[i]['elements'] = updatedElements;\n  //     if (targetIndex !== j)  setBlocks(updatedBlock);\n  //   }\n  // };\n\n\n  return React.createElement(\"ul\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 157\n    },\n    __self: this\n  }, blocks.map(function (_ref5, i) {\n    var header = _ref5.header,\n        id = _ref5.id,\n        elements = _ref5.elements;\n    return React.createElement(Item, {\n      key: id,\n      i: i,\n      setPosition: setPosition,\n      moveItem: moveItem,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 159\n      },\n      __self: this\n    }, React.createElement(Card, {\n      title: header,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 165\n      },\n      __self: this\n    }, elements.map(function (_ref6, j) {\n      var header = _ref6.header,\n          id = _ref6.id;\n      return React.createElement(ChildItem, {\n        parentIndex: i,\n        childIndex: j,\n        blocks: blocks,\n        setBlocks: setBlocks,\n        id: id,\n        header: header,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 168\n        },\n        __self: this\n      });\n    })));\n  }));\n}; // Spring configs\n\nvar onTop = {\n  zIndex: 1\n};\nvar flat = {\n  zIndex: 0,\n  transition: {\n    delay: 0.3\n  }\n};\nvar initialColors = [\"#FF008C\", \"#D309E1\", \"#9C1AFF\"];\nvar defaultObject = [{\n  id: 1,\n  header: \"Header\",\n  expanded: false,\n  error: false,\n  elements: [{\n    id: 1,\n    header: \"Title\",\n    component: \"text\",\n    content: {}\n  }, {\n    id: 2,\n    header: \"Text\",\n    component: \"text\",\n    content: {}\n  }]\n}, {\n  id: 2,\n  header: \"Content\",\n  expanded: false,\n  error: false,\n  elements: [{\n    id: 1,\n    header: \"Another\",\n    component: \"text\",\n    content: {}\n  }]\n}, {\n  id: 3,\n  header: \"Some other card that has a longer name\",\n  expanded: false,\n  error: false,\n  elements: [{\n    id: 1,\n    header: \"One\",\n    component: \"text\",\n    content: {}\n  }, {\n    id: 2,\n    header: \"Two\",\n    component: \"text\",\n    content: {}\n  }, {\n    id: 3,\n    header: \"Another text three\",\n    component: \"text\",\n    content: {}\n  }]\n}];","map":{"version":3,"sources":["/Users/mineshshah/minesh/drag-drop-list-framer/src/Example.tsx"],"names":["React","useEffect","useState","useRef","motion","useMotionValue","findIndex","move","Card","SubCard","Item","setPosition","moveItem","i","rest","isDragging","setDragging","ref","dragOriginY","height","current","offsetHeight","top","offsetTop","onTop","flat","boxShadow","bottom","event","stopImmediatePropagation","e","point","y","delta","set","get","ChildItem","parentIndex","childIndex","blocks","setBlocks","id","header","childPositions","setChildPosition","offset","moveChildItem","dragOffset","console","log","targetIndex","updatedElements","updatedBlock","Example","defaultObject","positions","map","elements","j","zIndex","transition","delay","initialColors","expanded","error","component","content"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { useEffect, useState, useRef } from \"react\";\nimport { motion, useMotionValue } from \"framer-motion\";\nimport { findIndex, Position } from \"./find-index\";\nimport move from \"array-move\";\nimport Card from './Card';\nimport SubCard from \"./SubCard\";\nimport {SubCardContainer} from \"./SubCard/styles\";\n\ninterface ItemProps {\n  setPosition: any,\n  moveItem: any,\n  i: number,\n  children: any\n}\n\nconst Item = ({ setPosition, moveItem, i, ...rest } : ItemProps, ) => {\n  const [isDragging, setDragging] = useState(false);\n\n  // We'll use a `ref` to access the DOM element that the `motion.li` produces.\n  // This will allow us to measure its height and position, which will be useful to\n  // decide when a dragging element should switch places with its siblings.\n  const ref = useRef<any>(null);\n  // By manually creating a reference to `dragOriginY` we can manipulate this value\n  // if the user is dragging this DOM element while the drag gesture is active to\n  // compensate for any movement as the items are re-positioned.\n  const dragOriginY = useMotionValue(0);\n  // Update the measured position of the item so we can calculate when we should rearrange.\n  useEffect(() => {\n    setPosition(i, {\n      height: ref.current.offsetHeight,\n      top: ref.current.offsetTop\n    });\n  });\n\n  return (\n    <motion.li\n      ref={ref}\n      initial={false}\n      // If we're dragging, we want to set the zIndex of that item to be on top of the other items.\n      animate={isDragging ? onTop : flat}\n      style={{ height: 'auto' }}\n      whileHover={{ boxShadow: `0px 1px 4px rgba(0, 0, 0, 0.2)` }}\n      // whileTap={{ scale: 1.12 }}\n      drag=\"y\"\n      dragOriginY={dragOriginY}\n      dragConstraints={{ top: 0, bottom: 0 }}\n      dragElastic={1}\n      onDragStart={(event) => {\n          setDragging(true)\n      }\n      }\n      onDragEnd={(event) => {\n        event && event.stopImmediatePropagation();\n        setDragging(false)\n      }}\n      onDrag={(e, { point }) => {\n        return moveItem(i, point.y);\n      }}\n      // onUpdate={({ y, top }) => {\n      //   !isDragging && dragOriginY.set((y || top) as number);\n      // }}\n      positionTransition={({ delta }) => {\n      if (isDragging) {\n        // If we're dragging, we want to \"undo\" the items movement within the list\n        // by manipulating its dragOriginY. This will keep the item under the cursor,\n        // even though it's jumping around the DOM.\n        dragOriginY.set(dragOriginY.get() + delta.y);\n      }\n\n      // If `positionTransition` is a function and returns `false`, it's telling\n      // Motion not to animate from its old position into its new one. If we're\n      // dragging, we don't want any animation to occur.\n      return !isDragging;\n    }}\n      {...rest}\n    />\n  );\n};\n\ninterface ChildItemInterface {\n  parentIndex: number ,\n  childIndex: number,\n  blocks: any,\n  setBlocks: any,\n  id: any,\n  header: string\n}\n\nexport const ChildItem = ({parentIndex, childIndex, blocks, setBlocks, id, header }: ChildItemInterface) => {\n  const childPositions = useRef<any>({}).current;\n  const setChildPosition = (childIndex: number, offset: Position) => {\n    return (childPositions[childIndex] = offset);\n  };\n  const moveChildItem = (childIndex: number, dragOffset: number) => {\n    console.log(childPositions)\n    const targetIndex = findIndex(childIndex, dragOffset, childPositions);\n    const updatedElements = move([...blocks][parentIndex]['elements'], childIndex, targetIndex);\n    const updatedBlock = [...blocks];\n    updatedBlock[parentIndex]['elements'] = updatedElements;\n    if (targetIndex !== childIndex)  setBlocks(updatedBlock);\n  };\n\n  return (\n      <Item\n          key={id}\n          i={childIndex}\n          setPosition={setChildPosition}\n          moveItem={moveChildItem}\n      >\n        <SubCard title={header} key={id}/>\n      </Item>\n  );\n};\n\nexport const Example = () => {\n  // const [colors, setColors] = useState(initialColors);\n  const [blocks, setBlocks] = useState(defaultObject);\n\n\n  // We need to collect an array of height and position data for all of this component's\n  // `Item` children, so we can later us that in calculations to decide when a dragging\n  // `Item` should swap places with its siblings.\n  const positions = useRef<Position[]>([]).current;\n  const setPosition = (i: number, offset: Position) => {\n    return (positions[i] = offset);\n  };\n  // const setChildPosition = (i: number) => ( j: number, offset: Position) => {\n  //   // console.log(positions[i])\n  //   // if (!positions[i]['elements'] ){\n  //   //   positions[i]['elements'] = []\n  //   // }\n  //   // positions[i]['elements'][j] = offset;\n  //   // childPositions[i] = childPositions[i] ?  : []\n  // };\n\n  // Find the ideal index for a dragging item based on its position in the array, and its\n  // current drag offset. If it's different to its current index, we swap this item with that\n  // sibling.\n  const moveItem = (i: number, dragOffset: number) => {\n    const targetIndex = findIndex(i, dragOffset, positions);\n    if (targetIndex !== i) setBlocks(move(blocks, i, targetIndex));\n  };\n\n  // const moveChildItem = (i:number) => (j: number, dragOffset: number) => {\n  //   if(positions[i]['elements']) {\n  //     // console.log(positions)\n  //     const targetIndex = findIndex(j, dragOffset, positions[i]['elements']);\n  //     const updatedElements = move([...blocks][i]['elements'], j, targetIndex);\n  //     const updatedBlock = [...blocks];\n  //     updatedBlock[i]['elements'] = updatedElements;\n  //     if (targetIndex !== j)  setBlocks(updatedBlock);\n  //   }\n  // };\n\n  return (\n    <ul>\n      {blocks.map(({header, id, elements}, i) => (\n        <Item\n          key={id}\n          i={i}\n          setPosition={setPosition}\n          moveItem={moveItem}\n        >\n          <Card title={header}>\n            {elements.map(({header, id}, j) => {\n                  return (\n                      <ChildItem\n                          parentIndex={i}\n                          childIndex={j}\n                          blocks={blocks}\n                          setBlocks={setBlocks}\n                          id={id}\n                          header={header}/>\n                  );\n                }\n            )}\n          </Card>\n        </Item>\n      ))}\n    </ul>\n  );\n};\n\n\n// Spring configs\nconst onTop = { zIndex: 1 };\nconst flat = {\n  zIndex: 0,\n  transition: { delay: 0.3 }\n};\n\nconst initialColors = [\"#FF008C\", \"#D309E1\", \"#9C1AFF\"];\n\nconst defaultObject = [\n  {\n    id: 1,\n    header: \"Header\",\n    expanded: false,\n    error: false,\n    elements: [\n      {\n        id: 1,\n        header: \"Title\",\n        component: \"text\",\n        content:{}\n      },\n      {\n        id: 2,\n        header: \"Text\",\n        component: \"text\",\n        content:{}\n      }\n    ]\n  },\n  {\n    id: 2,\n    header: \"Content\",\n    expanded: false,\n    error: false,\n    elements: [\n      {\n        id: 1,\n        header: \"Another\",\n        component: \"text\",\n        content:{}\n      },\n    ]\n  },\n  {\n    id: 3,\n    header: \"Some other card that has a longer name\",\n    expanded: false,\n    error: false,\n    elements: [\n      {\n        id: 1,\n        header: \"One\",\n        component: \"text\",\n        content:{}\n      },\n      {\n        id: 2,\n        header: \"Two\",\n        component: \"text\",\n        content:{}\n      },\n      {\n        id: 3,\n        header: \"Another text three\",\n        component: \"text\",\n        content:{}\n      }\n    ]\n  }\n];\n"]},"metadata":{},"sourceType":"module"}