{"ast":null,"code":"import _slicedToArray from \"/Users/mineshshah/minesh/drag-drop-list-framer/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/mineshshah/minesh/drag-drop-list-framer/src/Example.tsx\";\nimport * as React from \"react\";\nimport { useEffect, useState, useRef } from \"react\";\nimport { motion, useMotionValue } from \"framer-motion\";\nimport { findIndex } from \"./find-index\";\nimport move from \"array-move\";\nimport Expandable from './Card';\n\nvar Item = function Item(_ref) {\n  var color = _ref.color,\n      setPosition = _ref.setPosition,\n      moveItem = _ref.moveItem,\n      i = _ref.i;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isDragging = _useState2[0],\n      setDragging = _useState2[1]; // We'll use a `ref` to access the DOM element that the `motion.li` produces.\n  // This will allow us to measure its height and position, which will be useful to\n  // decide when a dragging element should switch places with its siblings.\n\n\n  var ref = useRef(null); // By manually creating a reference to `dragOriginY` we can manipulate this value\n  // if the user is dragging this DOM element while the drag gesture is active to\n  // compensate for any movement as the items are re-positioned.\n\n  var dragOriginY = useMotionValue(0);\n  console.log(dragOriginY); // Update the measured position of the item so we can calculate when we should rearrange.\n\n  useEffect(function () {\n    setPosition(i, {\n      height: ref.current.offsetHeight,\n      top: ref.current.offsetTop\n    });\n  });\n  return React.createElement(motion.li, {\n    ref: ref,\n    initial: false // If we're dragging, we want to set the zIndex of that item to be on top of the other items.\n    ,\n    animate: isDragging ? onTop : flat,\n    style: {\n      background: color,\n      height: 'auto'\n    },\n    whileHover: {\n      boxShadow: \"0px 1px 4px rgba(0, 0, 0, 0.2)\"\n    } // whileTap={{ scale: 1.12 }}\n    ,\n    drag: \"y\",\n    dragOriginY: dragOriginY,\n    dragConstraints: {\n      top: 0,\n      bottom: 0\n    },\n    dragElastic: 1,\n    onDragStart: function onDragStart() {\n      return setDragging(true);\n    },\n    onDragEnd: function onDragEnd() {\n      return setDragging(false);\n    },\n    onDrag: function onDrag(e, _ref2) {\n      var point = _ref2.point;\n      return moveItem(i, point.y);\n    } // onUpdate={({ y, top }) => {\n    //   !isDragging && dragOriginY.set((y || top) as number);\n    // }}\n    ,\n    positionTransition: function positionTransition(_ref3) {\n      var delta = _ref3.delta;\n\n      if (isDragging) {\n        // If we're dragging, we want to \"undo\" the items movement within the list\n        // by manipulating its dragOriginY. This will keep the item under the cursor,\n        // even though it's jumping around the DOM.\n        dragOriginY.set(dragOriginY.get() + delta.y);\n      } // If `positionTransition` is a function and returns `false`, it's telling\n      // Motion not to animate from its old position into its new one. If we're\n      // dragging, we don't want any animation to occur.\n\n\n      return !isDragging;\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 36\n    },\n    __self: this\n  }, React.createElement(Expandable, {\n    title: 'hello',\n    isDragging: isDragging,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70\n    },\n    __self: this\n  }));\n};\n\nexport var Example = function Example() {\n  var _useState3 = useState(initialColors),\n      _useState4 = _slicedToArray(_useState3, 2),\n      colors = _useState4[0],\n      setColors = _useState4[1]; // We need to collect an array of height and position data for all of this component's\n  // `Item` children, so we can later us that in calculations to decide when a dragging\n  // `Item` should swap places with its siblings.\n\n\n  var positions = useRef([]).current;\n\n  var setPosition = function setPosition(i, offset) {\n    return positions[i] = offset;\n  }; // Find the ideal index for a dragging item based on its position in the array, and its\n  // current drag offset. If it's different to its current index, we swap this item with that\n  // sibling.\n\n\n  var moveItem = function moveItem(i, dragOffset) {\n    var targetIndex = findIndex(i, dragOffset, positions);\n    if (targetIndex !== i) setColors(move(colors, i, targetIndex));\n  };\n\n  return React.createElement(\"ul\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93\n    },\n    __self: this\n  }, colors.map(function (color, i) {\n    return React.createElement(Item, {\n      key: color,\n      i: i,\n      color: color,\n      setPosition: setPosition,\n      moveItem: moveItem,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 95\n      },\n      __self: this\n    });\n  }));\n}; // Spring configs\n\nvar onTop = {\n  zIndex: 1\n};\nvar flat = {\n  zIndex: 0,\n  transition: {\n    delay: 0.3\n  }\n};\nvar initialColors = [\"#FF008C\", \"#D309E1\", \"#9C1AFF\"];\nvar heights = {\n  \"#FF008C\": 60,\n  \"#D309E1\": 80,\n  \"#9C1AFF\": 90,\n  \"#7700FF\": 100\n};","map":{"version":3,"sources":["/Users/mineshshah/minesh/drag-drop-list-framer/src/Example.tsx"],"names":["React","useEffect","useState","useRef","motion","useMotionValue","findIndex","move","Expandable","Item","color","setPosition","moveItem","i","isDragging","setDragging","ref","dragOriginY","console","log","height","current","offsetHeight","top","offsetTop","onTop","flat","background","boxShadow","bottom","e","point","y","delta","set","get","Example","initialColors","colors","setColors","positions","offset","dragOffset","targetIndex","map","zIndex","transition","delay","heights"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { useEffect, useState, useRef } from \"react\";\nimport { motion, useMotionValue } from \"framer-motion\";\nimport { findIndex, Position } from \"./find-index\";\nimport move from \"array-move\";\nimport Expandable from './Card';\n\ninterface ItemProps {\n  color : string,\n  setPosition: any,\n  moveItem: any,\n  i: number\n}\n\nconst Item = ({ color, setPosition, moveItem, i } : ItemProps ) => {\n  const [isDragging, setDragging] = useState(false);\n\n  // We'll use a `ref` to access the DOM element that the `motion.li` produces.\n  // This will allow us to measure its height and position, which will be useful to\n  // decide when a dragging element should switch places with its siblings.\n  const ref = useRef<any>(null);\n  // By manually creating a reference to `dragOriginY` we can manipulate this value\n  // if the user is dragging this DOM element while the drag gesture is active to\n  // compensate for any movement as the items are re-positioned.\n  const dragOriginY = useMotionValue(0);\n  console.log(dragOriginY)\n  // Update the measured position of the item so we can calculate when we should rearrange.\n  useEffect(() => {\n    setPosition(i, {\n      height: ref.current.offsetHeight,\n      top: ref.current.offsetTop\n    });\n  });\n\n  return (\n    <motion.li\n      ref={ref}\n      initial={false}\n      // If we're dragging, we want to set the zIndex of that item to be on top of the other items.\n      animate={isDragging ? onTop : flat}\n      style={{ background: color, height: 'auto' }}\n      whileHover={{ boxShadow: `0px 1px 4px rgba(0, 0, 0, 0.2)` }}\n      // whileTap={{ scale: 1.12 }}\n      drag=\"y\"\n      dragOriginY={dragOriginY}\n      dragConstraints={{ top: 0, bottom: 0 }}\n      dragElastic={1}\n      onDragStart={() => setDragging(true)}\n      onDragEnd={() => setDragging(false)}\n      onDrag={(e, { point }) => {\n        return moveItem(i, point.y);\n      }}\n      // onUpdate={({ y, top }) => {\n      //   !isDragging && dragOriginY.set((y || top) as number);\n      // }}\n      positionTransition={({ delta }) => {\n      if (isDragging) {\n        // If we're dragging, we want to \"undo\" the items movement within the list\n        // by manipulating its dragOriginY. This will keep the item under the cursor,\n        // even though it's jumping around the DOM.\n        dragOriginY.set(dragOriginY.get() + delta.y);\n      }\n\n      // If `positionTransition` is a function and returns `false`, it's telling\n      // Motion not to animate from its old position into its new one. If we're\n      // dragging, we don't want any animation to occur.\n      return !isDragging;\n    }}\n    >\n      <Expandable title={'hello'} isDragging={isDragging}/>\n    </motion.li>\n  );\n};\n\nexport const Example = () => {\n  const [colors, setColors] = useState(initialColors);\n\n  // We need to collect an array of height and position data for all of this component's\n  // `Item` children, so we can later us that in calculations to decide when a dragging\n  // `Item` should swap places with its siblings.\n  const positions = useRef<Position[]>([]).current;\n  const setPosition = (i: number, offset: Position) => (positions[i] = offset);\n\n  // Find the ideal index for a dragging item based on its position in the array, and its\n  // current drag offset. If it's different to its current index, we swap this item with that\n  // sibling.\n  const moveItem = (i: number, dragOffset: number) => {\n    const targetIndex = findIndex(i, dragOffset, positions);\n    if (targetIndex !== i) setColors(move(colors, i, targetIndex));\n  };\n\n  return (\n    <ul>\n      {colors.map((color, i) => (\n        <Item\n          key={color}\n          i={i}\n          color={color}\n          setPosition={setPosition}\n          moveItem={moveItem}\n        />\n      ))}\n    </ul>\n  );\n};\n\n// Spring configs\nconst onTop = { zIndex: 1 };\nconst flat = {\n  zIndex: 0,\n  transition: { delay: 0.3 }\n};\n\nconst initialColors = [\"#FF008C\", \"#D309E1\", \"#9C1AFF\"];\nconst heights:any = {\n  \"#FF008C\": 60,\n  \"#D309E1\": 80,\n  \"#9C1AFF\": 90,\n  \"#7700FF\": 100\n};\n"]},"metadata":{},"sourceType":"module"}